
# 1463번

"""
# 시작 체크 리스트
1. 1시간이 지났으나 발상 불가 또는 아예 다른 길 O
2. 코드 50% 정도 완성
3. 1시간 보다 더 걸려서 코드 완성.
4. 코드는 다 돌아가는 효율성에서 걸림.
5. 코드완성

# 완료 후 체크 리스트
1. 아예 모르겠음
2. 중간 정도 이해함.
3. 완벽히 이해함. O
"""

# 내가 푼 방법 , 하지만 문제를 제대로 파악못함.
# 코드를 적은 이후, 문제를 파악했지만 더 작은 횟수를 어떻게 뽑아내야하는지 감을 잡지못함.

n = int(input())
answer = n
cnt = 0
while answer != 1:
    print('cnt = '+ str(cnt))
    print('answer = ' + str(answer))
    if answer % 3 == 0:
        answer = answer // 3
        cnt += 1
    elif answer % 2 == 0:
        answer = answer // 2
        cnt += 1
    else:
        answer = answer - 1
        cnt += 1
print(cnt)


# 올바른 풀이
# DP 를 사용해야된다는 것 파악.

# i가 4일 때, i가 1,2,3일 때의 방법을 재활용해야한다.

# 4는 -1, %2의 방법에 적용가능하다.
# %2의 방법을 적용할 때는, i가 2일때의 방법에 +1을 하면 된다.
# 그럼 -1의 방법이 적은 횟수인지 %2의 방법이 적은 횟수인지 어떻게 판단할까?
# (물론 4의 경우는 똑같이 횟수가 2가 되지만 6의 경우 다르다.)
# -1의 방법과 %2의 방법이 다른점은 -1은 적용 조건이 없고 %2는 적용 조건이 있다는 것이다.
# 그럼 우선적으로 -1의 방법을 쓴 횟수를 저장하고 %2의 방법을 쓴 횟수와 비교하면 된다.

# 6과 같은 %2, %3이 다 적용되는 경우를 생각해서 if -else 가 아닌 if -if로 구성한다.

n = int(input())

dp = [0, 0, 1, 1]
for i in range(4,n+1):
    dp.append(dp[i-1]+1)
    if i % 2 == 0:
        dp[i] = min(dp[i//2] + 1,dp[i])
    if i % 3 == 0:
        dp[i] = min(dp[i//3] + 1, dp[i])

print(dp[n])

















