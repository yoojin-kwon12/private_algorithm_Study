# 10844번

"""
# 시작 체크 리스트
1. 1시간이 지났으나 발상 불가 또는 아예 다른 길 O
2. 코드 50% 정도 완성
3. 1시간 보다 더 걸려서 코드 완성.
4. 코드는 다 돌아가는 효율성에서 걸림.
5. 코드완성

# 완료 후 체크 리스트
1. 아예 모르겠음
2. 중간 정도 이해함.
3. 완벽히 이해함. O
"""

# n < 10일 때,
# n=2 이면 2! * 8 +1
# n=3 이면 3! * 7 +1
# 라고 생각했는데 적용되지 않을듯....
"""
n = int(input())



dp = [0,9,17]

for i in range(n):
    dp.append((dp[i-1]*2) -1)

print(dp[n] % 1000000000)

"""

# 2차원 배열로 해야된다는 것을 어떻게 생각해낼 것인가?
# -> 1차원 배열로 할 수 있는 방법(피보나치, if문, 배열 숫자의 규칙) 모두 해결하지 못했을 때 생각해볼 수 있다.

# 2차원 배열로 시도해볼때 각 index는 어떻게 설정할까?
# 우선 n의 값(자리값)은 생각이 날것이다.
# 생각할때 인덱스로 잡을 수 있는 조건을 생각하자. 그게 문제 해결하기 편하다.

# 답안풀이처럼 뒷자리수와 계단수의 갯수를 활용해서 이차원배열을 만드는 방법말고
# 앞자리수와 계단수의 갯수를 활용해서 이차원배열을 만들어 보고자 했다.
# -> 이유는 내가 실제로 이문제를 보고 이차원배열로 풀어야겠다고 생각했다면 앞자리수를 활용하고자 했을것 같아서
# -> 결론적으로 실패. 앞자리수같은 경우 1로 시작해야되는데 그러면 index와 -1이 차이난다. 더 복잡해짐.

# 2차원 배열의 index로 표를 만들어서 값을 보고 규칙을 찾아본다.
# 보통 케이스를 3개 정도 노가다로 적어서 규칙을 찾아볼 수 있지만 그 방법으로 해결책이 나오지 않을 수도 있다.
# 잘못된 것이 아니니 표의 값으로도 생각해보자.
# 인덱스가 같은 값의 규칙으로 구할 수 없을 수도 있다. 앞, 뒤의 인덱스도 확인하자.


n = int(input())

dp = [[0] * 10 for j in range(n+1)]

dp[1] =[0,1,1,1,1,1,1,1,1,1]

for i in range(2, n+1):
    dp[i][0] = dp[i-1][1]
    dp[i][9] = dp[i-1][8]

    for j in range(1,9):
        dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]

print(sum(dp[n]) % 1000000000)















