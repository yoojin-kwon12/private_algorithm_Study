# 2579번
# 참고 사이트 : https://infinitt.tistory.com/255

"""
# 시작 체크 리스트
1. 1시간이 지났으나 발상 불가 또는 아예 다른 길 0
2. 코드 50% 정도 완성
3. 1시간 보다 더 걸려서 코드 완성.
4. 코드는 다 돌아가는데 효율성에서 걸림.
5. 코드완성

# 완료 후 체크 리스트
1. 아예 모르겠음
2. 중간 정도 이해함.
3. 완벽히 이해함.
"""

# 연속된 세개 계단 밟으면 안됨
# 한칸씩, 두칸씩 오를수 있음
# 마지막 칸 밟아야함

# 한칸당 나올 수 있는 경우의 수 중(조건을 다 고려해서) 가장 값이 큰 값만 저장하면 되지않을까? 순열 처럼?
# 그렇게 하려고했는데...연속된 세개 계단을 밟을 수 없다는건 어떻게 고려해야하지?
# 우선 무식하게 처음부터 규칙을 찾으려고 하면 어느정도 보인다.
# 마지막 계단은 무조건 밟아야하므로 기준이되는 계단까지 밟으려면 어떤 경로가 있는지 확인해서 max로 출력한다.

# 규칙은 쉽게 이해했다.
# 근데 계속 런타임 에러가 발생했다.
# inp와 result 선언 시, n+3을 하니 런타임 에러가 나지않았다. 계단의 갯수가 1개일때 문제가 생길 수 있으니
# 그런것이다.
# 나는 항상 에러가 나면 인덱스 에러가 자주 나는 것 같다. 풀면서 인덱스를 항상 생각 해야겠다.

n = int(input())

# 처음에 (n+1)을 했다가 오류가 났다. 대충 j-3까지연산을 진행하니까 n+3인것 같긴한데
inp = [0] * (n+3)
result = [0] * (n+3)
# result = [0] * 301

for i in range(1, n+1):
    inp[i] = int(input())

# print(inp)

result[1] = inp[1]
# 총 계단의 갯수가 1,2개라고 한다면 런타임 에러가 발생할 수 있다.
result[2] = inp[1] + inp[2]
result[3] = max(inp[1] + inp[3], inp[2] + inp[3])
# print(result)

for j in range(4, n+1):
    result[j] = max(result[j-2] + inp[j], result[j-3] + inp[j-1] + inp[j])
print(result[n])